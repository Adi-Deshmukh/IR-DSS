<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Railway DSS - Improved with Real Data</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        html, body { height: 100%; }
        body { margin: 0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; overflow-x: hidden; }
        /* App layout: side-by-side map and dashboard */
        .app-layout { display: flex; height: 100vh; width: 100%; overflow: hidden; }
        #map { flex: 1 1 auto; height: 100%; width: calc(100% - 360px); }
        
        .control-panel {
            position: relative; background: white;
            padding: 16px; box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            z-index: 10; width: 360px; max-width: 400px; height: 100vh; overflow-y: auto; box-sizing: border-box;
            border-left: 1px solid #e6e6e6;
            scrollbar-width: thin; /* Firefox */
            scrollbar-color: #cfd8e3 transparent; /* Firefox */
        }
        
        .control-section {
            margin-bottom: 14px; padding: 14px; background: #f8f9fa;
            border-radius: 8px; border-left: 4px solid #3498db;
        }
        
        .control-section h3 {
            margin: 0 0 15px 0; color: #2c3e50; font-size: 16px;
            text-transform: uppercase; letter-spacing: 0.5px;
        }
        
        .btn {
            padding: 10px 16px; margin: 5px; border: none; border-radius: 6px;
            cursor: pointer; font-weight: 600; transition: all 0.2s;
            text-transform: uppercase; letter-spacing: 0.3px;
        }
        
        .btn-success { background: #27ae60; color: white; }
        .btn-success:hover { background: #229954; transform: translateY(-1px); }
        .btn-warning { background: #f39c12; color: white; }
        .btn-warning:hover { background: #e67e22; transform: translateY(-1px); }
        .btn-danger { background: #e74c3c; color: white; }
        .btn-danger:hover { background: #c0392b; transform: translateY(-1px); }
        .btn-primary { background: #3498db; color: white; }
        .btn-primary:hover { background: #2980b9; transform: translateY(-1px); }
        
        .status-display {
            background: white; padding: 15px; border-radius: 8px;
            margin: 10px 0; border: 1px solid #ddd;
        }
        
        .status-item {
            display: flex; justify-content: space-between;
            margin-bottom: 10px; font-size: 14px;
        }
        
        .status-label { font-weight: 600; color: #555; }
        .status-value { color: #2c3e50; font-weight: 500; }
        
        .speed-control {
            margin: 15px 0;
        }
        
        .speed-slider {
            width: 100%; margin: 10px 0;
        }
        
        .speed-display {
            text-align: center; font-size: 18px; font-weight: bold;
            color: #3498db; margin: 10px 0;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block; margin-bottom: 5px; font-weight: 600;
            color: #555; font-size: 12px;
        }
        
        .form-control {
            width: 100%; padding: 8px 12px; border: 1px solid #ddd;
            border-radius: 4px; font-size: 13px;
        }
        
        .train-info {
            position: absolute; bottom: 10px; right: 10px;
            background: white; padding: 15px; border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1); z-index: 1000;
            min-width: 250px; display: none;
        }
        
        .legend {
            position: absolute; bottom: 10px; left: 10px;
            background: white; padding: 15px; border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1); z-index: 1000;
        }
        
        .legend h4 { margin: 0 0 10px 0; color: #2c3e50; font-size: 14px; }
        
        .legend-item {
            display: flex; align-items: center; margin-bottom: 8px; font-size: 12px;
        }
        
        .legend-icon { margin-right: 8px; font-size: 16px; }
        
        .notification {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            padding: 12px 20px; border-radius: 6px; color: white;
            font-weight: 500; z-index: 1001; opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .notification.show { opacity: 1; }
        .notification.success { background: #27ae60; }
        .notification.error { background: #e74c3c; }
        .notification.info { background: #3498db; }
        
        /* Train marker animations */
        .train-marker {
            font-size: 20px; transition: all 0.3s ease;
            filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3));
        }
        
        .train-marker:hover {
            transform: scale(1.3); cursor: pointer;
        }
        
        .train-running { animation: pulse 2s infinite; }
        
        /* Track-specific styling */
        .track-1 { 
            border: 2px solid #3498db; 
            border-radius: 50%; 
            background: rgba(52, 152, 219, 0.1);
        }
        
        .track-2 { 
            border: 2px solid #e74c3c; 
            border-radius: 50%; 
            background: rgba(231, 76, 60, 0.1);
        }
        
        /* Notification system */
        .notification-container {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 2000;
            max-width: 400px;
        }
        
        .notification {
            background: white;
            border-left: 4px solid #3498db;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            margin-bottom: 10px;
            padding: 12px 16px;
            transform: translateX(-100%);
            animation: slideIn 0.3s ease forwards;
            position: relative;
        }
        
        .notification.arriving {
            border-left-color: #27ae60;
        }
        
        .notification.departing {
            border-left-color: #f39c12;
        }
        
        .notification.dwelling {
            border-left-color: #9b59b6;
        }
        
        .notification-message {
            font-size: 14px;
            color: #2c3e50;
            margin: 0;
        }
        
        .notification-time {
            font-size: 12px;
            color: #7f8c8d;
            margin-top: 4px;
        }
        
        @keyframes slideIn {
            to { transform: translateX(0); }
        }
        
        @keyframes slideOut {
            to { transform: translateX(-100%); }
        }
        
        .notification.removing {
            animation: slideOut 0.3s ease forwards;
        }
        
        /* Train type styling */
        .freight-train { filter: hue-rotate(45deg); }
        .passenger-train { filter: brightness(1.1); }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .control-panel { right: 5px; top: 5px; min-width: 280px; }
        }
        
        /* Decision Approval Styles */
        .decision-item {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .decision-item:hover {
            background: #e9ecef;
            border-color: #dee2e6;
        }
        
        .decision-item.high-impact {
            border-left: 4px solid #e74c3c;
        }
        
        .decision-item.medium-impact {
            border-left: 4px solid #f39c12;
        }
        
        .decision-item.low-impact {
            border-left: 4px solid #27ae60;
        }
        
        .decision-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }
        
        .decision-type {
            font-weight: bold;
            font-size: 12px;
        }
        
        .decision-impact {
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 12px;
            color: white;
        }
        
        .decision-impact.high {
            background: #e74c3c;
        }
        
        .decision-impact.medium {
            background: #f39c12;
        }
        
        .decision-impact.low {
            background: #27ae60;
        }
        
        .decision-description {
            font-size: 11px;
            color: #666;
            margin-bottom: 5px;
        }
        
        .decision-savings {
            font-size: 10px;
            color: #27ae60;
            font-weight: bold;
        }
        
        .decision-actions {
            display: flex;
            gap: 5px;
            margin-top: 8px;
        }
        
        .decision-actions .btn {
            font-size: 10px;
            padding: 4px 8px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        
        .btn-approve {
            background: #27ae60;
            color: white;
        }
        
        .btn-approve:hover {
            background: #229954;
        }
        
        .btn-reject {
            background: #e74c3c;
            color: white;
        }
        
        .btn-reject:hover {
            background: #c0392b;
        }
        
        /* Decision Popup Styles */
        .decision-popup {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 4000;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            border-left: 4px solid #3498db;
            min-width: 300px;
            max-width: 400px;
        }
        
        .decision-popup-content {
            padding: 15px;
        }
        
        .decision-popup-content h4 {
            margin: 0 0 10px 0;
            color: #2c3e50;
            font-size: 16px;
        }
        
        .decision-popup-content p {
            margin: 5px 0;
            font-size: 14px;
            color: #34495e;
        }
        
        .decision-popup-actions {
            margin-top: 15px;
            display: flex;
            gap: 8px;
        }
        
        .decision-popup-actions button {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
        }
        
        .decision-popup-actions .btn-approve {
            background: #27ae60;
            color: white;
        }
        
        .decision-popup-actions .btn-reject {
            background: #e74c3c;
            color: white;
        }
        
        .decision-popup-actions button:last-child {
            background: #95a5a6;
            color: white;
        }
        
        /* Modal Styles */
        .modal {
            position: fixed;
            z-index: 3000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }
        
        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 0;
            border-radius: 8px;
            width: 80%;
            max-width: 600px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        
        .modal-header {
            background: #3498db;
            color: white;
            padding: 15px 20px;
            border-radius: 8px 8px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .modal-header h4 {
            margin: 0;
            font-size: 16px;
        }
        
        .close {
            color: white;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
        }
        
        .close:hover {
            opacity: 0.7;
        }
        
        .modal-body {
            padding: 20px;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .modal-footer {
            padding: 15px 20px;
            border-top: 1px solid #eee;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }
        
        .impact-metric {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 12px;
        }
        
        .metric-label {
            color: #666;
        }
        
        .metric-value {
            font-weight: bold;
        }

        /* Dark mode overrides */
        body.dark {
            background: #0f141a;
            color: #e6e9ed;
        }
        body.dark .control-panel { background: #151c24; box-shadow: 0 6px 24px rgba(0,0,0,0.6); border-left-color: #223042; }
        
        /* Panel header tidy */
        .panel-header { position: sticky; top: 0; background: inherit; padding: 6px 0 8px 0; z-index: 5; }
        .panel-header h2 { line-height: 1.2; }
        .section-title { margin: 14px 0 8px 0; font-weight: 700; letter-spacing: .3px; }

        /* Scrollbar styling for WebKit (Chrome/Edge) to visually cover right edge */
        .control-panel::-webkit-scrollbar { width: 10px; }
        .control-panel::-webkit-scrollbar-track { background: inherit; }
        .control-panel::-webkit-scrollbar-thumb { background: #cfd8e3; border-radius: 8px; }
        body.dark .control-panel::-webkit-scrollbar-thumb { background: #2b3a4c; }
        body.dark .control-panel h2 { color: #e6e9ed; }
        body.dark .control-section { background: #11171e; border-left-color: #6aa9ff; }
        body.dark .status-display { background: #0f141a; border-color: #263241; }
        body.dark .status-label { color: #9fb0c3; }
        body.dark .status-value { color: #e6e9ed; }
        body.dark .form-control { background: #0f141a; color: #e6e9ed; border-color: #263241; }
        body.dark .legend { background: #151c24; color: #e6e9ed; }
        body.dark .legend h4 { color: #e6e9ed; }
        body.dark .notification { background: #151c24; color: #e6e9ed; border-left-color: #6aa9ff; }
        body.dark .decision-item { background: #0f141a; border-color: #263241; }
        body.dark .decision-item:hover { background: #11171e; border-color: #2b3a4c; }
        body.dark .decision-popup { background: #151c24; border-left-color: #6aa9ff; }
        body.dark .decision-popup-content h4 { color: #e6e9ed; }
        body.dark .decision-popup-content p { color: #cdd7e1; }
        body.dark .modal-content { background: #151c24; }
        body.dark .modal-header { background: #223042; }
        body.dark .metric-label { color: #9fb0c3; }
        body.dark .train-marker { filter: drop-shadow(2px 2px 6px rgba(0,0,0,0.6)); }
        /* Leaflet popups in dark mode */
        body.dark .leaflet-popup-content-wrapper { background: #151c24; color: #e6e9ed; }
        body.dark .leaflet-popup-tip { background: #151c24; }
        body.dark .leaflet-control-attribution { background: rgba(15,20,26,0.7); color: #9fb0c3; }
    </style>
</head>
<body>
    <!-- Notification Container -->
    <div class="notification-container" id="notificationContainer"></div>
    
    <div class="app-layout">
        <!-- Map Container -->
        <div id="map"></div>

        <!-- Control Panel -->
        <aside class="control-panel" role="complementary">
        <div class="panel-header" style="display: flex; align-items: center; justify-content: space-between; gap: 10px; margin: 0 0 12px 0;">
            <h2 style="margin: 0; color: #2c3e50;">üöÇ Railway DSS</h2>
            <div style="display: flex; gap: 8px; align-items: center;">
                <select id="basemapSelect" class="form-control" style="width: 150px; height: 34px;">
                    <option value="satellite">Satellite</option>
                    <option value="dark">Dark</option>
                    <option value="light">Light</option>
                    <option value="streets">Streets</option>
                    <option value="topographic">Topographic</option>
                    <option value="terrain">Terrain</option>
                </select>
                <button id="themeToggle" class="btn btn-secondary" title="Toggle dark mode" style="padding: 8px 12px;">üåô Dark</button>
            </div>
        </div>
        
        <!-- Simulation Controls -->
        <div class="control-section">
            <h3>Simulation Control</h3>
            <div>
                <button id="startBtn" class="btn btn-success">‚ñ∂ Start</button>
                <button id="stopBtn" class="btn btn-warning">‚è∏ Stop</button>
                <button id="resetBtn" class="btn btn-danger">‚èπ Reset</button>
            </div>
            
            <div class="status-display">
                <div class="status-item">
                    <span class="status-label">Status:</span>
                    <span id="status" class="status-value">Stopped</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Sim Time:</span>
                    <span id="simTime" class="status-value">00:00</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Active Trains:</span>
                    <span id="activeTrains" class="status-value">0</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Completed:</span>
                    <span id="completedTrains" class="status-value">0</span>
                </div>
            </div>
        </div>

        <!-- Speed Control -->
        <div class="control-section">
            <h3>Simulation Speed</h3>
            <div class="speed-control">
                <div class="speed-display">
                    <span id="speedValue">1.0</span>x Speed
                </div>
                <input type="range" id="speedSlider" class="speed-slider" 
                       min="0.1" max="5.0" step="0.1" value="1.0">
                <div style="display: flex; justify-content: space-between; font-size: 11px; color: #666;">
                    <span>0.1x (Slow)</span>
                    <span>5.0x (Fast)</span>
                </div>
            </div>
            <button id="normalSpeedBtn" class="btn btn-primary">Reset to 1x</button>
        </div>

        <!-- Train Management -->
        <div class="control-section">
            <h3>Train Management</h3>
            <div class="form-group">
                <label for="trainSelect">Select Train:</label>
                <select id="trainSelect" class="form-control">
                    <option value="">Choose train...</option>
                </select>
            </div>
            <div class="form-group">
                <label for="delayInput">Add Delay (minutes):</label>
                <input type="number" id="delayInput" class="form-control" 
                       value="10" min="1" max="120">
            </div>
            <button id="addDelayBtn" class="btn btn-warning">‚ö† Add Delay</button>
        </div>

        <!-- Special Train -->
        <div class="control-section">
            <h3>Add Special Train</h3>
            <div class="form-group">
                <label for="specialTrainId">Train ID:</label>
                <input type="text" id="specialTrainId" class="form-control" 
                       placeholder="e.g., SP001">
            </div>
            <div class="form-group">
                <label for="specialDepTime">Departure (minutes):</label>
                <input type="number" id="specialDepTime" class="form-control" 
                       value="30" min="0">
            </div>
            <button id="addSpecialBtn" class="btn btn-primary">üöÜ Add Train</button>
        </div>

        <!-- Quick Actions -->
        <div class="control-section">
            <h3>Quick Actions</h3>
            <button id="optimizeBtn" class="btn btn-success">‚ö° Optimize Schedule</button>
            <button id="focusTrainsBtn" class="btn btn-primary">üéØ Focus Trains</button>
            <button id="refreshBtn" class="btn btn-primary">üîÑ Refresh</button>
            
            <div class="status-display" id="optimizationStatus" style="margin-top: 10px; display: none;">
                <div class="status-item">
                    <span class="status-label">MILP Status:</span>
                    <span class="status-value" id="milpStatus">Checking...</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Last Optimization:</span>
                    <span class="status-value" id="lastOptimization">Never</span>
                </div>
            </div>
        </div>

        <!-- Testing & Demo -->
        <div class="control-section">
            <h3>üß™ Testing & Demo</h3>
            <button id="testDecisionsBtn" class="btn btn-primary">üéØ Generate Test Decisions</button>
            <button id="testAddTrainBtn" class="btn btn-success">üöÇ Add Test Train</button>
            <button id="testDisruptionBtn" class="btn btn-warning">üö® Test Disruption</button>
            
            <div style="margin-top: 10px; padding: 8px; background: #f8f9fa; border-radius: 4px; font-size: 11px;">
                <div>‚Ä¢ <strong>Generate Test Decisions:</strong> Creates sample optimization decisions</div>
                <div>‚Ä¢ <strong>Add Test Train:</strong> Adds a train and triggers auto-optimization</div>
                <div>‚Ä¢ <strong>Test Disruption:</strong> Simulates delay and generates recovery decisions</div>
            </div>
        </div>

        <!-- Optimization Results Panel -->
        <div class="control-section" id="optimizationResults" style="display: none;">
            <h3>Latest Optimization Results</h3>
            <div class="status-display">
                <div class="status-item">
                    <span class="status-label">Trains Analyzed:</span>
                    <span class="status-value" id="trainsAnalyzed">0</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Schedules Updated:</span>
                    <span class="status-value" id="schedulesUpdated">0</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Delay Reduction:</span>
                    <span class="status-value" id="delayReduction">0 min</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Waiting Saved:</span>
                    <span class="status-value" id="waitingSaved">0 min</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Reordered:</span>
                    <span class="status-value" id="trainsReordered">0</span>
                </div>
            </div>
            <button id="clearResultsBtn" class="btn btn-danger" style="margin-top: 10px; font-size: 12px; padding: 5px 10px;">Clear Results</button>
        </div>

        <!-- Live Control Panel -->
        <div class="control-section" id="liveControlPanel" style="display: none;">
            <h3>üî¥ Live Railway Control</h3>
            <div class="status-display">
                <div class="status-item">
                    <span class="status-label">Control System:</span>
                    <span class="status-value" id="liveControlStatus">Inactive</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Live Decisions:</span>
                    <span class="status-value" id="liveDecisions">0</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Platforms Occupied:</span>
                    <span class="status-value" id="platformsOccupied">0</span>
                </div>
            </div>
            <div id="recentDecisions" style="margin-top: 10px; font-size: 11px; max-height: 100px; overflow-y: auto;">
                <strong>Recent Decisions:</strong>
                <div id="decisionsList">No decisions yet</div>
            </div>
            <button id="refreshLiveBtn" class="btn btn-primary" style="margin-top: 10px; font-size: 12px; padding: 5px 10px;">üîÑ Refresh</button>
        </div>

        <!-- Decision Approval Panel -->
        <div class="control-section" id="decisionApprovalPanel" style="display: none;">
            <h3>‚öñÔ∏è Decision Approval</h3>
            <div class="status-display">
                <div class="status-item">
                    <span class="status-label">Pending Decisions:</span>
                    <span class="status-value" id="pendingCount">0</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Auto-Approved:</span>
                    <span class="status-value" id="autoApprovedCount">0</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Total Savings:</span>
                    <span class="status-value" id="totalSavings">0 min</span>
                </div>
            </div>
            
            <div id="pendingDecisionsList" style="margin-top: 10px; max-height: 200px; overflow-y: auto;">
                <strong>Pending Decisions:</strong>
                <div id="decisionsContainer">No pending decisions</div>
            </div>
            
            <div style="margin-top: 10px;">
                <button id="refreshDecisionsBtn" class="btn btn-primary" style="font-size: 12px; padding: 5px 10px;" onclick="fetchPendingDecisions()">üîÑ Refresh</button>
                <button id="viewHistoryBtn" class="btn btn-secondary" style="font-size: 12px; padding: 5px 10px; margin-left: 5px;">üìä History</button>
                <button id="testDecisionsBtn" class="btn btn-warning" style="font-size: 12px; padding: 5px 10px; margin-left: 5px;" onclick="testDecisionSystem()">üß™ Test</button>
            </div>
        </aside>
    </div>

    <!-- Decision Modal -->
    <div id="decisionModal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h4 id="modalTitle">Decision Details</h4>
                <span class="close" onclick="closeDecisionModal()">&times;</span>
            </div>
            <div class="modal-body">
                <div id="decisionDetails"></div>
                <div id="impactAnalysis" style="margin-top: 15px;"></div>
            </div>
            <div class="modal-footer">
                <button id="approveBtn" class="btn btn-success" onclick="approveCurrentDecision()">‚úÖ Approve</button>
                <button id="rejectBtn" class="btn btn-danger" onclick="rejectCurrentDecision()">‚ùå Reject</button>
                <button class="btn btn-secondary" onclick="closeDecisionModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Train Info Panel -->
    <div id="trainInfo" class="train-info">
        <h4 style="margin: 0 0 10px 0;">Train Information</h4>
        <div id="trainDetails"></div>
    </div>

    <!-- Legend -->
    <div class="legend">
        <h4>Legend</h4>
        <div class="legend-item">
            <span class="legend-icon">üöÇ</span>
            <span>Running Train</span>
        </div>
        <div class="legend-item">
            <span class="legend-icon">üöÉ</span>
            <span>Train at Station</span>
        </div>
        <div class="legend-item">
            <span class="legend-icon">‚è∏Ô∏è</span>
            <span>Waiting Train</span>
        </div>
        <div class="legend-item">
            <span class="legend-icon">üèÅ</span>
            <span>Completed Journey</span>
        </div>
        <div class="legend-item">
            <span class="legend-icon" style="color: #e74c3c;">üî¥</span>
            <span>Station</span>
        </div>
        <div class="legend-item">
            <span class="legend-icon" style="color: #2c3e50;">‚îÅ</span>
            <span>Main Railway Track</span>
        </div>
        <div class="legend-item">
            <span class="legend-icon" style="color: #e67e22;">‚îÅ</span>
            <span>Spur Track</span>
        </div>
    </div>

    <!-- Notification -->
    <div id="notification" class="notification"></div>

    <!-- Scripts -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        const BACKEND_URL = 'http://localhost:5000';
        let map, trainMarkers = {}, updateInterval, decisionInterval, trackLayers = [], stationMarkers = [];
        let displayedEvents = new Set(); // Track displayed events to avoid duplicates

        // Notification system
        function showNotification(event) {
            const container = document.getElementById('notificationContainer');
            
            // Check if this event was already displayed
            const eventId = `${event.train_id}-${event.event_type}-${event.station}-${event.timestamp}`;
            if (displayedEvents.has(eventId)) {
                return;
            }
            displayedEvents.add(eventId);
            
            const notification = document.createElement('div');
            notification.className = `notification ${event.event_type}`;
            
            // Format timestamp
            const minutes = Math.floor(event.timestamp / 60);
            const seconds = Math.floor(event.timestamp % 60);
            const timeStr = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            notification.innerHTML = `
                <div class="notification-message">${event.message}</div>
                <div class="notification-time">Time: ${timeStr}</div>
            `;
            
            container.appendChild(notification);
            
            // Auto-remove after 5 seconds
            setTimeout(() => {
                notification.classList.add('removing');
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 5000);
        }

        async function fetchTrainEvents() {
            try {
                const response = await fetch(`${BACKEND_URL}/train_events`);
                const data = await response.json();
                
                // Show new events
                data.events.forEach(event => {
                    showNotification(event);
                });
            } catch (error) {
                console.error('Error fetching train events:', error);
            }
        }

        function animateMarkerToPosition(marker, startLatLng, endLatLng, duration) {
            const startTime = Date.now();
            
            function updatePosition() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Use easing function for smooth animation
                const easedProgress = easeInOutQuad(progress);
                
                const lat = startLatLng.lat + (endLatLng.lat - startLatLng.lat) * easedProgress;
                const lng = startLatLng.lng + (endLatLng.lng - startLatLng.lng) * easedProgress;
                
                marker.setLatLng([lat, lng]);
                
                if (progress < 1) {
                    requestAnimationFrame(updatePosition);
                }
            }
            
            requestAnimationFrame(updatePosition);
        }
        
        function easeInOutQuad(t) {
            return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
        }

        // Initialize map with light/dark basemaps
        map = L.map('map').setView([12.6, 77.2], 9);
        const lightBase = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap contributors'
        });
        const darkBase = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
            attribution: '¬© OpenStreetMap, ¬© CARTO'
        });
        const satelliteBase = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            attribution: 'Tiles ¬© Esri ‚Äî World Imagery'
        });
        const labelsOverlay = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_only_labels/{z}/{x}/{y}{r}.png', {
            attribution: '¬© OpenStreetMap, ¬© CARTO labels',
            pane: 'overlayPane'
        });
        const streetsBase = L.tileLayer('https://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap, HOT'
        });
        const topoBase = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap, SRTM | OpenTopoMap'
        });
        const terrainBase = L.tileLayer('https://stamen-tiles.a.ssl.fastly.net/terrain/{z}/{x}/{y}.jpg', {
            attribution: 'Map tiles by Stamen Design, under CC BY 3.0 ‚Äî Data ¬© OpenStreetMap'
        });
        lightBase.addTo(map);
        let currentBase = 'light';

        function setBasemap(name) {
            if (name === currentBase) return;
            // Remove existing
            if (currentBase === 'light') map.removeLayer(lightBase);
            if (currentBase === 'dark') map.removeLayer(darkBase);
            if (currentBase === 'satellite') { map.removeLayer(satelliteBase); if (map.hasLayer(labelsOverlay)) map.removeLayer(labelsOverlay); }
            if (currentBase === 'streets') map.removeLayer(streetsBase);
            if (currentBase === 'topographic') map.removeLayer(topoBase);
            if (currentBase === 'terrain') map.removeLayer(terrainBase);
            // Add new
            if (name === 'light') { lightBase.addTo(map); }
            if (name === 'dark') { darkBase.addTo(map); }
            if (name === 'satellite') { satelliteBase.addTo(map); labelsOverlay.addTo(map); }
            if (name === 'streets') { streetsBase.addTo(map); }
            if (name === 'topographic') { topoBase.addTo(map); }
            if (name === 'terrain') { terrainBase.addTo(map); }
            currentBase = name;
            try { localStorage.setItem('railway_basemap', name); } catch(e) {}
            // Update selector if needed
            const sel = document.getElementById('basemapSelect');
            if (sel && sel.value !== name) sel.value = name;
        }

        // Train status icons
        const TRAIN_ICONS = {
            'running': 'üöÇ',
            'dwelling': 'üöÉ', 
            'waiting': '‚è∏Ô∏è',
            'completed': 'üèÅ'
        };

        // Load data and setup
        async function init() {
            try {
                await loadTracks();
                await loadStations();
                await loadTrainList();
                setupEventListeners();
                
                // Check optimization capabilities
                await checkOptimizationStatus();
                
                showNotification('Railway DSS loaded with real data!', 'success');
            } catch (error) {
                console.error('Error initializing Railway DSS:', error);
                showNotification('Error loading simulation data. Please check if backend is running.', 'error');
            }
        }

        async function loadTracks() {
            try {
                const response = await fetch(`${BACKEND_URL}/tracks`);
                const data = await response.json();
                
                let mainTracks = 0;
                let spurTracks = 0;
                
                Object.values(data.tracks).forEach(track => {
                    if (track.coordinates && track.coordinates.length > 1) {
                        const coords = track.coordinates.map(c => [c[1], c[0]]);
                        
                        // Different colors based on track type and service
                        let color = '#2c3e50'; // Default main line
                        let weight = 4;
                        let opacity = 0.8;
                        
                        if (track.service === 'spur') {
                            color = '#e67e22'; // Orange for spurs
                            weight = 2;
                            opacity = 0.6;
                            spurTracks++;
                        } else {
                            color = '#2c3e50'; // Dark blue for main lines
                            weight = 4;
                            opacity = 0.8;
                            mainTracks++;
                        }
                        
                        const layer = L.polyline(coords, {
                            color: color,
                            weight: weight,
                            opacity: opacity
                        }).addTo(map);
                        
                        layer.bindPopup(`
                            <b>${track.name}</b><br>
                            Type: ${track.track_type}<br>
                            Service: ${track.service || 'main'}<br>
                            Length: ${track.length_km.toFixed(1)} km<br>
                            Segment: ${track.segment}
                        `);
                        
                        trackLayers.push(layer);
                    }
                });
                
                console.log(`Loaded ${trackLayers.length} track segments (${mainTracks} main, ${spurTracks} spurs)`);
                showNotification(`Loaded ${trackLayers.length} track segments from GeoJSON`, 'info');
            } catch (error) {
                console.error('Error loading tracks:', error);
            }
        }

        async function loadStations() {
            try {
                const response = await fetch(`${BACKEND_URL}/stations`);
                const data = await response.json();
                
                Object.values(data.stations).forEach(station => {
                    const marker = L.circleMarker([station.lat, station.lon], {
                        radius: station.major ? 12 : 8,
                        fillColor: '#e74c3c',
                        color: '#fff',
                        weight: 3,
                        opacity: 1,
                        fillOpacity: 0.9
                    }).addTo(map);
                    
                    marker.bindPopup(`
                        <b>${station.name}</b><br>
                        Code: ${station.code}<br>
                        Platforms: ${station.platforms}<br>
                        Type: ${station.major ? 'Major Junction' : 'Station'}
                    `);
                    
                    stationMarkers.push(marker);
                });
                
                console.log(`Loaded ${stationMarkers.length} stations`);
            } catch (error) {
                console.error('Error loading stations:', error);
            }
        }

        async function loadTrainList() {
            try {
                const response = await fetch(`${BACKEND_URL}/positions`);
                const data = await response.json();
                
                const trainSelect = document.getElementById('trainSelect');
                trainSelect.innerHTML = '<option value="">Choose train...</option>';
                
                // Get train list from backend
                const backendResponse = await fetch(`${BACKEND_URL}/`);
                const backendData = await backendResponse.json();
                
                // For now, add some sample train IDs
                const sampleTrains = ['12614', '12615', '16535', '56901', '12616'];
                sampleTrains.forEach(trainId => {
                    const option = document.createElement('option');
                    option.value = trainId;
                    option.textContent = `Train ${trainId}`;
                    trainSelect.appendChild(option);
                });
                
            } catch (error) {
                console.error('Error loading train list:', error);
            }
        }

        function setupEventListeners() {
            // Simulation controls
            document.getElementById('startBtn').addEventListener('click', startSimulation);
            document.getElementById('stopBtn').addEventListener('click', stopSimulation);
            document.getElementById('resetBtn').addEventListener('click', resetSimulation);
            
            // Speed control
            const speedSlider = document.getElementById('speedSlider');
            speedSlider.addEventListener('input', function() {
                const speed = parseFloat(this.value);
                document.getElementById('speedValue').textContent = speed.toFixed(1);
                setSimulationSpeed(speed);
            });
            
            document.getElementById('normalSpeedBtn').addEventListener('click', function() {
                speedSlider.value = 1.0;
                document.getElementById('speedValue').textContent = '1.0';
                setSimulationSpeed(1.0);
            });
            
            // Basemap selector
            const basemapSelect = document.getElementById('basemapSelect');
            if (basemapSelect) {
                basemapSelect.addEventListener('change', function() {
                    setBasemap(this.value);
                });
            }

            // Theme toggle
            document.getElementById('themeToggle').addEventListener('click', function() {
                const isDark = document.body.classList.toggle('dark');
                if (isDark) {
                    this.textContent = '‚òÄÔ∏è Light';
                    this.title = 'Toggle light mode';
                } else {
                    this.textContent = 'üåô Dark';
                    this.title = 'Toggle dark mode';
                }
                // Persist preference
                try { localStorage.setItem('railway_theme', isDark ? 'dark' : 'light'); } catch(e) {}
            });
            
            // Train management
            document.getElementById('addDelayBtn').addEventListener('click', addDelay);
            document.getElementById('addSpecialBtn').addEventListener('click', addSpecialTrain);
            
            // Quick actions
            document.getElementById('optimizeBtn').addEventListener('click', optimizeSchedule);
            document.getElementById('focusTrainsBtn').addEventListener('click', focusOnTrains);
            document.getElementById('refreshBtn').addEventListener('click', refreshData);
            
            // Testing & Demo buttons
            document.getElementById('testDecisionsBtn').addEventListener('click', generateTestDecisions);
            document.getElementById('testAddTrainBtn').addEventListener('click', addTestTrain);
            document.getElementById('testDisruptionBtn').addEventListener('click', testDisruption);
            
            // Optimization results
            document.getElementById('clearResultsBtn').addEventListener('click', function() {
                document.getElementById('optimizationResults').style.display = 'none';
                showNotification('Optimization results cleared', 'info');
            });
            
            // Live control
            document.getElementById('refreshLiveBtn').addEventListener('click', updateLiveControlStatus);
        }

        async function setSimulationSpeed(speed) {
            try {
                await fetch(`${BACKEND_URL}/set_speed`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({speed: speed})
                });
                showNotification(`Speed set to ${speed.toFixed(1)}x`, 'info');
            } catch (error) {
                console.error('Error setting speed:', error);
            }
        }

        async function updatePositions() {
            try {
                const response = await fetch(`${BACKEND_URL}/positions`);
                const data = await response.json();
                
                // Update UI
                document.getElementById('simTime').textContent = 
                    Math.floor(data.simulation_time / 60).toString().padStart(2, '0') + ':' +
                    (Math.floor(data.simulation_time) % 60).toString().padStart(2, '0');
                
                const activeCount = Object.values(data.positions).filter(p => p.status === 'running').length;
                const completedCount = Object.values(data.positions).filter(p => p.status === 'completed').length;
                
                document.getElementById('activeTrains').textContent = activeCount;
                document.getElementById('completedTrains').textContent = completedCount;
                
                // Fetch and display train events
                fetchTrainEvents();
                
                // Update train markers with smooth animation
                Object.entries(data.positions).forEach(([trainId, pos]) => {
                    const icon = TRAIN_ICONS[pos.status] || 'üöÇ';
                    const trackClass = `track-${pos.assigned_track || 1}`;
                    const typeClass = `${pos.train_type || 'passenger'}-train`;
                    const statusClass = pos.status === 'running' ? 'train-running' : '';
                    
                    if (trainMarkers[trainId]) {
                        // Smooth transition to new position
                        const marker = trainMarkers[trainId];
                        const currentLatLng = marker.getLatLng();
                        const newLatLng = L.latLng(pos.lat, pos.lon);
                        
                        // Only update if position actually changed
                        if (Math.abs(currentLatLng.lat - newLatLng.lat) > 0.0001 || 
                            Math.abs(currentLatLng.lng - newLatLng.lng) > 0.0001) {
                            
                            // Animate to new position
                            animateMarkerToPosition(marker, currentLatLng, newLatLng, 800);
                        }
                        
                        // Update icon and styling
                        marker.setIcon(L.divIcon({
                            html: `<div class="train-marker ${statusClass} ${trackClass} ${typeClass}">${icon}</div>`,
                            iconSize: [24, 24],
                            iconAnchor: [12, 12],
                            className: 'custom-train-icon'
                        }));
                    } else {
                        // Create new marker
                        const marker = L.marker([pos.lat, pos.lon], {
                            icon: L.divIcon({
                                html: `<div class="train-marker ${statusClass} ${trackClass} ${typeClass}">${icon}</div>`,
                                iconSize: [24, 24],
                                iconAnchor: [12, 12],
                                className: 'custom-train-icon'
                            })
                        }).addTo(map);
                        
                        marker.on('click', () => showTrainInfo(trainId, pos));
                        trainMarkers[trainId] = marker;
                    }
                    
                    // Update popup
                    const dwellingInfo = pos.status === 'dwelling' && pos.dwelling_time_remaining > 0 
                        ? `<br><strong>Dwelling:</strong> ${pos.dwelling_time_remaining.toFixed(1)} min remaining`
                        : '';
                    
                    trainMarkers[trainId].bindPopup(`
                        <b>üöÇ Train ${trainId}</b><br>
                        <strong>Type:</strong> ${pos.train_type}<br>
                        <strong>Status:</strong> ${pos.status}<br>
                        <strong>Track:</strong> ${pos.track_type}<br>
                        <strong>Speed:</strong> ${pos.speed.toFixed(1)} km/h<br>
                        <strong>Progress:</strong> ${(pos.progress * 100).toFixed(1)}%<br>
                        <strong>Delay:</strong> ${pos.delay.toFixed(1)} min<br>
                        <strong>Current:</strong> ${pos.current_segment}<br>
                        <strong>Next:</strong> ${pos.next_station}${dwellingInfo}
                    `);
                });
                
                // Remove old markers
                Object.keys(trainMarkers).forEach(trainId => {
                    if (!data.positions[trainId]) {
                        map.removeLayer(trainMarkers[trainId]);
                        delete trainMarkers[trainId];
                    }
                });

                // Update live control status during simulation
                updateLiveControlStatus();
                
            } catch (error) {
                console.error('Error updating positions:', error);
            }
        }

        function showTrainInfo(trainId, position) {
            const infoPanel = document.getElementById('trainInfo');
            const details = document.getElementById('trainDetails');
            
            details.innerHTML = `
                <div><strong>Train:</strong> ${trainId}</div>
                <div><strong>Status:</strong> ${position.status}</div>
                <div><strong>Speed:</strong> ${position.speed} km/h</div>
                <div><strong>Progress:</strong> ${(position.progress * 100).toFixed(1)}%</div>
                <div><strong>Delay:</strong> ${position.delay.toFixed(1)} minutes</div>
                <div><strong>Next Station:</strong> ${position.next_station}</div>
                <div><strong>Track:</strong> ${position.track_type}</div>
            `;
            
            infoPanel.style.display = 'block';
            
            // Hide after 5 seconds
            setTimeout(() => {
                infoPanel.style.display = 'none';
            }, 5000);
        }

        async function startSimulation() {
            try {
                await fetch(`${BACKEND_URL}/start_sim`, {method: 'POST'});
                document.getElementById('status').textContent = 'Running';
                updateInterval = setInterval(updatePositions, 1500); // Update every 1.5 seconds for smoother movement
                decisionInterval = setInterval(fetchPendingDecisions, 3000); // Check for decisions every 3 seconds
                
                // Immediately fetch decisions on start
                setTimeout(fetchPendingDecisions, 1000); // Fetch after 1 second
                
                showNotification('Simulation started!', 'success');
            } catch (error) {
                console.error('Error starting simulation:', error);
                showNotification('Error starting simulation', 'error');
            }
        }

        async function stopSimulation() {
            try {
                await fetch(`${BACKEND_URL}/stop_sim`, {method: 'POST'});
                document.getElementById('status').textContent = 'Stopped';
                if (updateInterval) clearInterval(updateInterval);
                if (decisionInterval) clearInterval(decisionInterval);
                showNotification('Simulation stopped', 'info');
            } catch (error) {
                console.error('Error stopping simulation:', error);
            }
        }

        async function resetSimulation() {
            try {
                await fetch(`${BACKEND_URL}/reset_sim`, {method: 'POST'});
                document.getElementById('status').textContent = 'Reset';
                document.getElementById('simTime').textContent = '00:00';
                document.getElementById('activeTrains').textContent = '0';
                document.getElementById('completedTrains').textContent = '0';
                
                // Clear train markers
                Object.values(trainMarkers).forEach(marker => map.removeLayer(marker));
                trainMarkers = {};
                
                if (updateInterval) clearInterval(updateInterval);
                showNotification('Simulation reset', 'info');
            } catch (error) {
                console.error('Error resetting simulation:', error);
            }
        }

        async function addDelay() {
            const trainId = document.getElementById('trainSelect').value;
            const delay = parseFloat(document.getElementById('delayInput').value);
            
            if (!trainId) {
                showNotification('Please select a train', 'error');
                return;
            }
            
            try {
                const response = await fetch(`${BACKEND_URL}/disrupt`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        train_id: trainId,
                        delay_minutes: delay
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    showNotification(`Added ${delay} min delay to ${trainId}`, 'success');
                } else {
                    showNotification(result.message, 'error');
                }
            } catch (error) {
                console.error('Error adding delay:', error);
                showNotification('Error adding delay', 'error');
            }
        }

        async function addSpecialTrain() {
            const trainId = document.getElementById('specialTrainId').value;
            const depTime = parseInt(document.getElementById('specialDepTime').value);
            
            if (!trainId) {
                showNotification('Please enter train ID', 'error');
                return;
            }
            
            try {
                const response = await fetch(`${BACKEND_URL}/special_train`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        train_id: trainId,
                        dep_time: depTime,
                        arr_time: depTime + 180,
                        speed_kmh: 65,
                        stops: ['SBC', 'MYA', 'MYS']
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    showNotification(`Special train ${trainId} added!`, 'success');
                    document.getElementById('specialTrainId').value = '';
                    await loadTrainList(); // Refresh train list
                } else {
                    showNotification(result.message, 'error');
                }
            } catch (error) {
                console.error('Error adding special train:', error);
                showNotification('Error adding special train', 'error');
            }
        }

        async function optimizeSchedule() {
            const optimizeBtn = document.getElementById('optimizeBtn');
            const originalText = optimizeBtn.textContent;
            
            try {
                // Disable button and show loading state
                optimizeBtn.disabled = true;
                optimizeBtn.textContent = '‚ö° Optimizing...';
                optimizeBtn.classList.remove('btn-success');
                optimizeBtn.classList.add('btn-warning');
                
                showNotification('Starting MILP optimization...', 'info');
                
                // First check if MILP is available
                const statusResponse = await fetch(`${BACKEND_URL}/optimization_status`);
                const status = await statusResponse.json();
                
                if (!status.milp_available) {
                    showNotification('MILP optimizer not available. Please install PuLP.', 'error');
                    return;
                }
                
                // Show optimization status
                document.getElementById('optimizationStatus').style.display = 'block';
                document.getElementById('milpStatus').textContent = `Optimizing ${status.active_trains} trains...`;
                
                // Run optimization
                const response = await fetch(`${BACKEND_URL}/optimize`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        // Include any disruption context if needed
                        trigger: 'manual',
                        timestamp: Date.now()
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    const trainsAffected = result.trains_affected || 0;
                    const changesApplied = result.changes_applied || 0;
                    const optimizationDetails = result.optimization_details || {};
                    
                    // Main success message
                    const message = `Optimization complete! ${trainsAffected} trains analyzed, ${changesApplied} schedules updated.`;
                    showNotification(message, 'success');
                    
                    // Update status display
                    document.getElementById('milpStatus').textContent = 'Available';
                    document.getElementById('lastOptimization').textContent = new Date().toLocaleTimeString();
                    
                    // Show and update optimization results panel
                    if (optimizationDetails.summary) {
                        const summary = optimizationDetails.summary;
                        document.getElementById('optimizationResults').style.display = 'block';
                        document.getElementById('trainsAnalyzed').textContent = trainsAffected;
                        document.getElementById('schedulesUpdated').textContent = changesApplied;
                        document.getElementById('delayReduction').textContent = `${summary.total_delay_reduction.toFixed(1)} min`;
                        document.getElementById('waitingSaved').textContent = `${summary.waiting_time_saved.toFixed(1)} min`;
                        document.getElementById('trainsReordered').textContent = summary.trains_reordered;
                    }
                    
                    // Display detailed optimization results
                    if (optimizationDetails.summary) {
                        const summary = optimizationDetails.summary;
                        let detailMessage = 'üöÇ Optimization Results:\\n';
                        
                        if (summary.total_delay_reduction > 0) {
                            detailMessage += `‚úÖ Total delay reduced: ${summary.total_delay_reduction.toFixed(1)} minutes\\n`;
                        }
                        
                        if (summary.waiting_time_saved > 0) {
                            detailMessage += `‚è±Ô∏è Waiting time saved: ${summary.waiting_time_saved.toFixed(1)} minutes\\n`;
                        }
                        
                        if (summary.trains_reordered > 0) {
                            detailMessage += `üîÑ Trains reordered: ${summary.trains_reordered}\\n`;
                        }
                        
                        if (summary.significant_improvements > 0) {
                            detailMessage += `üìà Significant improvements: ${summary.significant_improvements} trains\\n`;
                        }
                        
                        detailMessage += `üìä Average delay reduction: ${summary.average_delay_reduction.toFixed(1)} min/train`;
                        
                        // Show detailed summary after 1 second
                        setTimeout(() => showNotification(detailMessage, 'info'), 1000);
                    }
                    
                    // Show train-specific changes
                    if (optimizationDetails.train_changes && optimizationDetails.train_changes.length > 0) {
                        let trainDetails = 'üìã Train-specific changes:\\n';
                        
                        optimizationDetails.train_changes.forEach((change, index) => {
                            if (change.significant_change && index < 5) { // Show first 5 significant changes
                                const priority = change.priority.toUpperCase();
                                const type = change.train_type.charAt(0).toUpperCase() + change.train_type.slice(1);
                                
                                if (change.delay_reduction > 0) {
                                    trainDetails += `üü¢ ${change.train_id} (${priority} ${type}): -${change.delay_reduction.toFixed(1)}min delay\\n`;
                                } else if (change.waiting_time_saved > 0) {
                                    trainDetails += `üîµ ${change.train_id} (${priority} ${type}): -${change.waiting_time_saved.toFixed(1)}min waiting\\n`;
                                }
                            }
                        });
                        
                        if (trainDetails.length > 30) {
                            // Show train details after 3 seconds
                            setTimeout(() => showNotification(trainDetails, 'info'), 3000);
                        }
                    }
                    
                    // Log complete optimization results for debugging
                    console.log('Complete Optimization Results:', {
                        summary: optimizationDetails.summary,
                        trainChanges: optimizationDetails.train_changes,
                        trainsAnalyzed: optimizationDetails.total_trains_analyzed
                    });
                    
                } else {
                    showNotification(`Optimization failed: ${result.message}`, 'error');
                    document.getElementById('milpStatus').textContent = 'Error';
                }
                
            } catch (error) {
                console.error('Error during optimization:', error);
                showNotification('Optimization failed: Network error', 'error');
                document.getElementById('milpStatus').textContent = 'Error';
            } finally {
                // Restore button state
                optimizeBtn.disabled = false;
                optimizeBtn.textContent = originalText;
                optimizeBtn.classList.remove('btn-warning');
                optimizeBtn.classList.add('btn-success');
            }
        }

        async function checkOptimizationStatus() {
            try {
                const response = await fetch(`${BACKEND_URL}/optimization_status`);
                const status = await response.json();
                
                const statusDisplay = document.getElementById('optimizationStatus');
                const milpStatus = document.getElementById('milpStatus');
                const optimizeBtn = document.getElementById('optimizeBtn');
                
                if (status.milp_available) {
                    milpStatus.textContent = 'Available';
                    optimizeBtn.disabled = false;
                    statusDisplay.style.display = 'block';
                } else {
                    milpStatus.textContent = 'Not Available';
                    optimizeBtn.disabled = true;
                    optimizeBtn.title = 'MILP optimizer not available. Please install PuLP.';
                    statusDisplay.style.display = 'block';
                }
                
                // Update live control status
                if (status.live_control_available) {
                    document.getElementById('liveControlPanel').style.display = 'block';
                    
                    if (status.live_control) {
                        document.getElementById('liveControlStatus').textContent = 
                            status.live_control.running ? 'üü¢ Active' : 'üî¥ Inactive';
                        document.getElementById('liveDecisions').textContent = 
                            status.live_control.total_decisions || 0;
                        
                        // Update platform occupancy
                        let totalOccupied = 0;
                        if (status.live_control.stations) {
                            Object.values(status.live_control.stations).forEach(station => {
                                totalOccupied += station.occupied_platforms || 0;
                            });
                        }
                        document.getElementById('platformsOccupied').textContent = totalOccupied;
                        
                        // Update recent decisions
                        updateRecentDecisions(status.live_control.recent_decisions || []);
                    }
                } else {
                    document.getElementById('liveControlStatus').textContent = 'Not Available';
                }
                
            } catch (error) {
                console.error('Error checking optimization status:', error);
                document.getElementById('milpStatus').textContent = 'Unknown';
            }
        }
        
        async function updateLiveControlStatus() {
            try {
                const response = await fetch(`${BACKEND_URL}/live_decisions?limit=5`);
                const data = await response.json();
                
                if (data.success) {
                    updateRecentDecisions(data.decisions);
                    document.getElementById('liveDecisions').textContent = data.total_decisions || 0;
                    showNotification('Live control status updated', 'info');
                }
            } catch (error) {
                console.error('Error updating live control status:', error);
                showNotification('Error updating live control status', 'error');
            }
        }
        
        function updateRecentDecisions(decisions) {
            const decisionsList = document.getElementById('decisionsList');
            
            if (!decisions || decisions.length === 0) {
                decisionsList.innerHTML = 'No recent decisions';
                return;
            }
            
            let html = '';
            decisions.slice(-3).forEach(decision => {
                const time = new Date(decision.timestamp * 60000).toLocaleTimeString();
                let description = '';
                
                switch(decision.type) {
                    case 'platform_assignment':
                        description = `üöÇ ${decision.train_id} ‚Üí Platform ${decision.platform} at ${decision.station}`;
                        break;
                    case 'departure_optimization':
                        const saved = decision.time_saved ? ` (saved ${decision.time_saved.toFixed(1)}min)` : '';
                        description = `‚è∞ ${decision.train_id} departure optimized${saved}`;
                        break;
                    case 'full_optimization':
                        description = `üîß ${decision.train_id} schedule optimized`;
                        break;
                    default:
                        description = `${decision.train_id}: ${decision.type}`;
                }
                
                html += `<div style="margin: 3px 0; padding: 2px; background: #f0f0f0; border-radius: 3px;">
                    <small>${time}</small><br>
                    ${description}
                </div>`;
            });
            
            decisionsList.innerHTML = html;
        }

        function focusOnTrains() {
            if (Object.keys(trainMarkers).length > 0) {
                const group = new L.featureGroup(Object.values(trainMarkers));
                map.fitBounds(group.getBounds().pad(0.1));
                showNotification('Focused on active trains', 'info');
            } else {
                showNotification('No active trains to focus on', 'info');
            }
        }

        function refreshData() {
            updatePositions();
            showNotification('Data refreshed', 'info');
        }

        function showNotification(message, type) {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.className = `notification ${type} show`;
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }

        // Decision Management Functions
        let currentDecisionId = null;

        async function fetchPendingDecisions() {
            console.log('üîÑ Fetching pending decisions...');
            try {
                const response = await fetch(`${BACKEND_URL}/pending_decisions`);
                console.log('üì° Response received:', response.status, response.statusText);
                
                const data = await response.json();
                console.log('üì¶ Pending decisions response:', data);
                
                if (data.success === true) {
                    console.log(`‚úÖ Found ${data.decisions.length} decisions`);
                    updateDecisionPanel(data.decisions || []);
                    updateDecisionStats(data.stats || {});
                } else {
                    console.error('‚ùå Failed to fetch decisions:', data.message);
                    showNotification(`Failed to fetch decisions: ${data.message}`, 'error');
                }
            } catch (error) {
                console.error('üí• Error fetching decisions:', error);
                showNotification('Failed to fetch decisions', 'error');
            }
        }

        function updateDecisionPanel(decisions) {
            console.log(`üéØ Updating decision panel with ${decisions.length} decisions`);
            
            const container = document.getElementById('decisionsContainer');
            const pendingCount = document.getElementById('pendingCount');
            
            if (!container) {
                console.error('‚ùå decisionsContainer element not found!');
                return;
            }
            
            if (!pendingCount) {
                console.error('‚ùå pendingCount element not found!');
                return;
            }
            
            // Check for new decisions and show popup
            const previousCount = parseInt(pendingCount.textContent) || 0;
            if (decisions.length > previousCount && decisions.length > 0) {
                // Show popup for new decision
                const newDecision = decisions[decisions.length - 1]; // Show the latest one
                showDecisionPopup(newDecision);
            }
            
            pendingCount.textContent = decisions.length;
            console.log(`üìä Updated pending count to: ${decisions.length}`);
            
            if (decisions.length === 0) {
                container.innerHTML = '<div style="font-size: 11px; color: #666;">No pending decisions</div>';
                console.log('üìù Set "No pending decisions" message');
                return;
            }
            
            const decisionsHTML = decisions.map(decision => `
                <div class="decision-item ${decision.impact.toLowerCase()}-impact" onclick="showDecisionDetails('${decision.id}')">
                    <div class="decision-header">
                        <span class="decision-type">${decision.type}</span>
                        <span class="decision-impact ${decision.impact.toLowerCase()}">${decision.impact}</span>
                    </div>
                    <div class="decision-description">${decision.description}</div>
                    <div class="decision-savings">Savings: ${decision.expected_savings} min</div>
                    <div class="decision-actions" onclick="event.stopPropagation()">
                        <button class="btn btn-approve" onclick="approveDecision('${decision.id}')">‚úÖ</button>
                        <button class="btn btn-reject" onclick="rejectDecision('${decision.id}')">‚ùå</button>
                    </div>
                </div>
            `).join('');
            
            container.innerHTML = decisionsHTML;
            console.log(`‚úÖ Successfully rendered ${decisions.length} decision items`);
            console.log('üé® Decision HTML:', decisionsHTML.substring(0, 200) + '...');
        }

        function showDecisionPopup(decision) {
            // Create a popup notification for new decision
            const popup = document.createElement('div');
            popup.className = 'decision-popup';
            popup.innerHTML = `
                <div class="decision-popup-content">
                    <h4>üöÇ New Decision Required</h4>
                    <p><strong>${decision.type}</strong> for Train ${decision.train_id}</p>
                    <p>${decision.description}</p>
                    <div class="decision-popup-actions">
                        <button class="btn-approve" onclick="approveDecision('${decision.id}'); this.closest('.decision-popup').remove();">Approve</button>
                        <button class="btn-reject" onclick="rejectDecision('${decision.id}'); this.closest('.decision-popup').remove();">Reject</button>
                        <button onclick="this.closest('.decision-popup').remove();">Later</button>
                    </div>
                </div>
            `;
            document.body.appendChild(popup);
            
            // Auto-remove after 10 seconds
            setTimeout(() => {
                if (popup.parentNode) {
                    popup.remove();
                }
            }, 10000);
        }

        function updateDecisionStats(stats) {
            // Safely handle undefined or null stats object
            const safeStats = stats || {};
            
            const autoApprovedElement = document.getElementById('autoApprovedCount');
            const totalSavingsElement = document.getElementById('totalSavings');
            
            if (autoApprovedElement) {
                autoApprovedElement.textContent = safeStats.auto_approved || 0;
            }
            
            if (totalSavingsElement) {
                totalSavingsElement.textContent = `${safeStats.total_savings || 0} min`;
            }
        }

        async function showDecisionDetails(decisionId) {
            try {
                const response = await fetch(`${BACKEND_URL}/pending_decisions`);
                const data = await response.json();
                
                if (data.success === true) {
                    const decision = data.decisions.find(d => d.id === decisionId);
                    if (decision) {
                        currentDecisionId = decisionId;
                        displayDecisionModal(decision);
                    }
                }
            } catch (error) {
                console.error('Error fetching decision details:', error);
                showNotification('Failed to load decision details', 'error');
            }
        }

        function displayDecisionModal(decision) {
            const modal = document.getElementById('decisionModal');
            const modalTitle = document.getElementById('modalTitle');
            const decisionDetails = document.getElementById('decisionDetails');
            const impactAnalysis = document.getElementById('impactAnalysis');
            
            modalTitle.textContent = `${decision.type} Decision`;
            
            decisionDetails.innerHTML = `
                <div class="impact-metric">
                    <span class="metric-label">Type:</span>
                    <span class="metric-value">${decision.type}</span>
                </div>
                <div class="impact-metric">
                    <span class="metric-label">Impact Level:</span>
                    <span class="metric-value decision-impact ${decision.impact.toLowerCase()}">${decision.impact}</span>
                </div>
                <div class="impact-metric">
                    <span class="metric-label">Expected Savings:</span>
                    <span class="metric-value">${decision.expected_savings} minutes</span>
                </div>
                <div class="impact-metric">
                    <span class="metric-label">Created:</span>
                    <span class="metric-value">${new Date(decision.created_at).toLocaleString()}</span>
                </div>
                <div style="margin-top: 15px;">
                    <strong>Description:</strong>
                    <p style="margin: 5px 0; font-size: 12px; color: #666;">${decision.description}</p>
                </div>
            `;
            
            if (decision.impact_analysis) {
                impactAnalysis.innerHTML = `
                    <strong>Impact Analysis:</strong>
                    <div style="margin-top: 5px; font-size: 11px;">
                        ${Object.entries(decision.impact_analysis).map(([key, value]) => 
                            `<div class="impact-metric">
                                <span class="metric-label">${key.replace(/_/g, ' ').toUpperCase()}:</span>
                                <span class="metric-value">${value}</span>
                            </div>`
                        ).join('')}
                    </div>
                `;
            }
            
            modal.style.display = 'block';
        }

        function closeDecisionModal() {
            document.getElementById('decisionModal').style.display = 'none';
            currentDecisionId = null;
        }

        async function approveDecision(decisionId) {
            try {
                console.log(`üéØ Approving decision: ${decisionId}`);
                showNotification('Processing decision approval...', 'info');
                
                const response = await fetch(`${BACKEND_URL}/approve_decision`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ decision_id: decisionId })
                });
                
                const result = await response.json();
                console.log('üìã Approval result:', result);
                
                if (result.success === true) {
                    const trainId = result.train_id || 'Unknown';
                    showNotification(`‚úÖ Decision approved! Applied to train ${trainId}`, 'success');
                    
                    // Show visual feedback
                    const decisionElement = document.querySelector(`[onclick*="${decisionId}"]`);
                    if (decisionElement) {
                        decisionElement.style.border = '2px solid #27ae60';
                        decisionElement.style.backgroundColor = '#d5eee1';
                        setTimeout(() => {
                            decisionElement.style.opacity = '0.7';
                            decisionElement.innerHTML += '<div style="position: absolute; top: 5px; right: 5px; background: #27ae60; color: white; padding: 2px 6px; border-radius: 10px; font-size: 10px;">‚úì APPLIED</div>';
                        }, 500);
                    }
                    
                    fetchPendingDecisions(); // Refresh the list
                    closeDecisionModal();
                } else {
                    showNotification(result.message || 'Failed to approve decision', 'error');
                }
            } catch (error) {
                console.error('Error approving decision:', error);
                showNotification('Failed to approve decision', 'error');
            }
        }

        async function rejectDecision(decisionId) {
            try {
                const response = await fetch(`${BACKEND_URL}/reject_decision`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ decision_id: decisionId })
                });
                
                const result = await response.json();
                
                if (result.success === true) {
                    showNotification('Decision rejected', 'info');
                    fetchPendingDecisions(); // Refresh the list
                    closeDecisionModal();
                } else {
                    showNotification(result.message || 'Failed to reject decision', 'error');
                }
            } catch (error) {
                console.error('Error rejecting decision:', error);
                showNotification('Failed to reject decision', 'error');
            }
        }

        function approveCurrentDecision() {
            if (currentDecisionId) {
                approveDecision(currentDecisionId);
            }
        }

        function rejectCurrentDecision() {
            if (currentDecisionId) {
                rejectDecision(currentDecisionId);
            }
        }

        async function viewDecisionHistory() {
            try {
                const response = await fetch('/api/decision_history');
                const data = await response.json();
                
                if (data.status === 'success') {
                    displayHistoryModal(data.decisions);
                } else {
                    showNotification('Failed to load decision history', 'error');
                }
            } catch (error) {
                console.error('Error fetching decision history:', error);
                showNotification('Failed to load decision history', 'error');
            }
        }

        function displayHistoryModal(decisions) {
            const modal = document.getElementById('decisionModal');
            const modalTitle = document.getElementById('modalTitle');
            const decisionDetails = document.getElementById('decisionDetails');
            const impactAnalysis = document.getElementById('impactAnalysis');
            
            modalTitle.textContent = 'Decision History';
            
            decisionDetails.innerHTML = `
                <div style="max-height: 300px; overflow-y: auto;">
                    ${decisions.map(decision => `
                        <div class="decision-item" style="margin-bottom: 10px;">
                            <div class="decision-header">
                                <span class="decision-type">${decision.type}</span>
                                <span class="decision-impact ${decision.status.toLowerCase()}">${decision.status}</span>
                            </div>
                            <div class="decision-description">${decision.description}</div>
                            <div style="font-size: 10px; color: #999; margin-top: 5px;">
                                ${new Date(decision.created_at).toLocaleString()} | 
                                Savings: ${decision.expected_savings} min
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
            
            impactAnalysis.innerHTML = '';
            
            // Hide approve/reject buttons for history view
            document.getElementById('approveBtn').style.display = 'none';
            document.getElementById('rejectBtn').style.display = 'none';
            
            modal.style.display = 'block';
        }

        // Add event listeners for decision panel
        document.addEventListener('DOMContentLoaded', function() {
            // Existing initialization...
            
            // Add decision panel event listeners
            const refreshDecisionsBtn = document.getElementById('refreshDecisionsBtn');
            const viewHistoryBtn = document.getElementById('viewHistoryBtn');
            
            if (refreshDecisionsBtn) {
                refreshDecisionsBtn.addEventListener('click', fetchPendingDecisions);
            }
            
            if (viewHistoryBtn) {
                viewHistoryBtn.addEventListener('click', viewDecisionHistory);
            }
            
            // Close modal when clicking outside
            window.addEventListener('click', function(event) {
                const modal = document.getElementById('decisionModal');
                if (event.target === modal) {
                    closeDecisionModal();
                }
            });
            
            // Show decision approval button and fetch initial decisions
            const decisionApprovalBtn = document.createElement('button');
            decisionApprovalBtn.textContent = '‚öñÔ∏è Decisions';
            decisionApprovalBtn.className = 'btn btn-secondary';
            decisionApprovalBtn.style.marginLeft = '5px';
            decisionApprovalBtn.onclick = function() {
                const panel = document.getElementById('decisionApprovalPanel');
                panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
                if (panel.style.display === 'block') {
                    fetchPendingDecisions();
                }
            };
            
            // Add button to control panel
            const controlHeader = document.querySelector('.control-panel h3');
            if (controlHeader) {
                controlHeader.parentNode.insertBefore(decisionApprovalBtn, controlHeader.nextSibling);
            }
        });

        // Test & Demo Functions
        async function generateTestDecisions() {
            console.log('üß™ Generating test decisions...');
            showNotification('Generating test decisions...', 'info');
            
            try {
                // Just refresh the pending decisions to trigger the backend test generation
                await fetchPendingDecisions();
                showNotification('‚ú® Test decisions generated! Check the decision panel.', 'success');
            } catch (error) {
                console.error('Error generating test decisions:', error);
                showNotification('‚ùå Failed to generate test decisions', 'error');
            }
        }

        async function addTestTrain() {
            console.log('üöÇ Adding test train...');
            showNotification('Adding test train...', 'info');
            
            try {
                const testTrainId = `TEST${Date.now()}`;
                const response = await fetch(`${BACKEND_URL}/special_train`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        train_id: testTrainId,
                        dep_time: 45,
                        arr_time: 180,
                        speed_kmh: 70,
                        stops: ['SBC', 'MYA', 'MYS'],
                        train_type: 'express',
                        priority: 'high'
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    console.log('‚úÖ Test train added:', result);
                    showNotification(`üöÇ Test train ${testTrainId} added! Generated ${result.new_decisions_generated || 0} new decisions.`, 'success');
                    
                    // Refresh decisions to show new ones
                    setTimeout(() => fetchPendingDecisions(), 1000);
                } else {
                    throw new Error(result.message || 'Failed to add train');
                }
            } catch (error) {
                console.error('Error adding test train:', error);
                showNotification('‚ùå Failed to add test train', 'error');
            }
        }

        async function testDisruption() {
            console.log('üö® Creating test disruption...');
            showNotification('Creating test disruption...', 'info');
            
            try {
                // Get a random train from the system
                const trainsResponse = await fetch(`${BACKEND_URL}/positions`);
                const trainsData = await trainsResponse.json();
                
                if (!trainsData.trains || trainsData.trains.length === 0) {
                    throw new Error('No trains available for disruption test');
                }
                
                const randomTrain = trainsData.trains[Math.floor(Math.random() * trainsData.trains.length)];
                const disruptionDelay = Math.floor(Math.random() * 15) + 5; // 5-20 minutes
                
                const response = await fetch(`${BACKEND_URL}/disrupt`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        train_id: randomTrain.train_id,
                        delay_minutes: disruptionDelay,
                        station: 'KSR Bengaluru'
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    console.log('‚úÖ Test disruption created:', result);
                    showNotification(`üö® Added ${disruptionDelay}min delay to ${randomTrain.train_id}. Generated ${result.new_decisions_generated || 0} recovery decisions.`, 'warning');
                    
                    // Refresh decisions to show new ones
                    setTimeout(() => fetchPendingDecisions(), 1000);
                } else {
                    throw new Error(result.message || 'Failed to create disruption');
                }
            } catch (error) {
                console.error('Error creating test disruption:', error);
                showNotification('‚ùå Failed to create test disruption', 'error');
            }
        }

        // Test function for debugging decision system
        function testDecisionSystem() {
            console.log('üß™ Testing decision system...');
            console.log('üîç BACKEND_URL:', BACKEND_URL);
            console.log('üîç Decision container exists:', !!document.getElementById('decisionsContainer'));
            console.log('üîç Pending count exists:', !!document.getElementById('pendingCount'));
            fetchPendingDecisions();
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Apply saved theme
            try {
                const saved = localStorage.getItem('railway_theme');
                if (saved === 'dark') {
                    document.body.classList.add('dark');
                    const t = document.getElementById('themeToggle');
                    if (t) { t.textContent = '‚òÄÔ∏è Light'; t.title = 'Toggle light mode'; }
                }
                // Apply saved basemap or default to satellite
                const savedBase = localStorage.getItem('railway_basemap');
                if (savedBase) {
                    setBasemap(savedBase);
                } else {
                    setBasemap('satellite');
                }
                const sel = document.getElementById('basemapSelect');
                if (sel && sel.value !== currentBase) sel.value = currentBase;
            } catch(e) {}
            init();
        });
    </script>
</body>
</html>
